#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RESOLUTION 1/5 //cells per degree
#define RINVERSE 5
#define WIDTH 17
#define SPACE 5.5
#define GOALTICK 12

#define BLACK 40
#define POWER 50

float courseProbs[360*RESOLUTION];//this is the probs to assign if it sees an obstacle
float lastProbs[360*RESOLUTION];
float currentProbs[360*RESOLUTION];//probability arrays
//0011000100101001
int course = 0x3229;
int location = 0;
bool stopped = false;
bool flag
int lastLocation = 0;
int goal;

task followLine(){
	int temp = 0;
	int bkw = 35*1.5;
	/*start sequence
				int max_sweeps = 20; //# of times robot will sweep to find line
        int sweeps = 0; // iterator for sweeps
        int sweep_time = 1; // duration of sweep
        int dir = 2; // check right first
        while(true){
            sweep_time += 2*sweeps*sweeps;
            if(dir == 1){ //Turn left
                motor[leftMotor] = -30;
                motor[rightMotor] = 30;
            }
            else if(dir == 2){ //Turn right
                motor[leftMotor] = 30;
                motor[rightMotor] = -30;
            }
            int temp = 0;
            for(int t = 0;t<sweep_time;t++){ // time spent sweeping
	            if(SensorValue(light) < BLACK){ // found line
	                dir = 0; // go straight again
	                temp = 1;
	                break;
	            }
	            wait1Msec(1);
          	}
          	if(temp) break;
            if(sweeps > max_sweeps) break; // reached max n# of sweeps
            // switch direction of sweep
            if(dir == 1) dir = 2;
            else dir = 1;
            sweeps += 1;
      		}*/
	while(!stopped){
		//motor[leftMotor]=30;
		if(SensorValue(light)<BLACK){
			motor[leftMotor] = 20;
			motor[rightMotor] =40;
			temp = 1;
			//wait1Msec(10);
		}
		if(SensorValue(light)>BLACK){//on white
			//motor[leftMotor] = 32+(32*1.5-bkw)/6;
		  //motor[rigedhtMotor] = bkw/1.5+(32/3-bkw)/6;
			//if(temp==0&&bkw>-32*1.5-(32*1.5-bkw)/6)
			//	bkw-=1;
			//else if(temp){
			//	bkw = 32*1.5;
			//	temp = 0;
			motor[leftMotor] = 20;
			motor[rightMotor]=-10;
			}
			//wait1Msec(10);
		}
	}


int unitTicks(float lapTicks){//converts angles into seconds
		int ans = (int)((float)RINVERSE*lapTicks/360.0);
		return ans;
}

float min_distance = 30; //min obstacle distance to trigger event (in)

bool readSonar(){
	nxtDisplayString(0, "Object Dist: %f", SensorValue[sonar]);
	if(SensorValue[sonar] <= min_distance){ //detected object 
		nxtDisplayString(1,"Object Detected");
		return true;
	}	
	else{
		return false;
	}	
}

void updateProbabilities(bool sonarReading, int distance){//updates the probability arrays
	distance = distance*RESOLUTION;//scales distance to match array length
	float temp[360*RESOLUTION]; //this array is the current probabilities shifted my the distance
	//these are for assigning values to temp**********************************
	for(int i = distance; i< 360*RESOLUTION; i++){
			temp[i] = currentProbs[i-distance];
	}
	for(int i = 0; i<distance;i++){
			temp[i] = currentProbs[360*RESOLUTION-distance+i];	
	}
	//****************************************************************
	//this one is for the actual algorithm
	for(int i = 0; i<360*RESOLUTION;i++){
		lastProbs[i] = sonarReading ? 1.5*courseProbs[i]+0.5 : 2.0-1.5*courseProbs[i];
		currentProbs[i] = lastProbs[i]*temp[i];
	}
	//finding the max of the prob array
	float max = -100.0;
	for(int i = 0;i<360*RESOLUTION;i++){
		if(currentProbs[i]>max){
			max = currentProbs[i];
			location = i*RINVERSE;
		}
	}
	nxtDisplayClearTextLine(3);
	nxtDisplayString(3,"%f",max);
	
	for(int i = 0;i<360*RESOLUTION;i++){
		currentProbs[i] /= max;
	}
	
}

task localization(){
	goal  = GOALTICK*360/16-GOALTICK*360/16%5;
	//initializing courseProbs to the correct values***************************************
	int index = 0;
	for(int i = 0;i<16;i++){
		int prob = (course>>i)&1;
		for(int j = 0;j<22*RESOLUTION+i%2;j++){//have to change this if we change RESOLUTION
			index++;
			if(index<360*RESOLUTION){
				if(j<SPACE){
					courseProbs[index] = prob;
				}
				else{
					courseProbs[index] = prob;
				}
				if(i%2 == 1){
						courseProbs[index] = courseProbs[index]/2+courseProbs[index-1]/2;
				}
			}
		}
	}
	//***********************************************************
	for(int i = 0;i<360*RESOLUTION;i++){
		currentProbs[i] = 1;	
	}
	nMotorEncoder[leftMotor] = 0;
	int tick = 0;
	while(true){
		if(nMotorEncoder[leftMotor]>=unitTicks(3570)){ //every x ticks update probability
			nMotorEncoder[leftMotor] = 0;
			nxtDisplayClearTextLine(0);
			nxtDisplayClearTextLine(1);
			nxtDisplayClearTextLine(2);
			nxtDisplayString(2,"%d",location);
			lastLocation = location;
			updateProbabilities(readSonar(),RINVERSE);
			if(lastLocation== goal>5? goal-5: 355 && location==goal){
				if(flag&&tick>=360*RESOLUTION-1)
					stopped = true;
				else
					flag = true;
			}
			tick++;
		}
		nxtDisplayClearTextLine(4);
		nxtDisplayString(4,"%d",nMotorEncoder[leftMotor]);
	}
}

task main()
{
	startTask(followLine);
	startTask(localization);
	while(!stopped){}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
}
