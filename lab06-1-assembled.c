#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RESOLUTION 1/5 //cells per degree
#define RINVERSE 5
#define WIDTH 17 //in degrees
#define SPACE 5.5
#define BLACK 40
#define POWER 50

float courseProbs[360*RESOLUTION];//this is the probs to assign if it sees an obstacle
float lastProbs[360*RESOLUTION];
float currentProbs[360*RESOLUTION];//probability arrays
//1011001000111001
int course = 0xB239;
int location = 0;

task followLine(){
	int temp = 0;
	int bkw = 35*1.5;
	/*start sequence
				int max_sweeps = 20; //# of times robot will sweep to find line
        int sweeps = 0; // iterator for sweeps
        int sweep_time = 1; // duration of sweep
        int dir = 2; // check right first
        while(true){
            sweep_time += 2*sweeps*sweeps;
            if(dir == 1){ //Turn left
                motor[leftMotor] = -30;
                motor[rightMotor] = 30;
            }
            else if(dir == 2){ //Turn right
                motor[leftMotor] = 30;
                motor[rightMotor] = -30;
            }
            int temp = 0;
            for(int t = 0;t<sweep_time;t++){ // time spent sweeping
	            if(SensorValue(light) < BLACK){ // found line
	                dir = 0; // go straight again
	                temp = 1;
	                break;
	            }
	            wait1Msec(1);
          	}
          	if(temp) break;
            if(sweeps > max_sweeps) break; // reached max n# of sweeps
            // switch direction of sweep
            if(dir == 1) dir = 2;
            else dir = 1;
            sweeps += 1;
      		}*/
	while(true){
		//motor[leftMotor]=30;
		if(SensorValue(light)<BLACK){
			motor[leftMotor] = 20;
			motor[rightMotor] = 15;
			temp = 1;
			//wait1Msec(10);
		}
		if(SensorValue(light)>BLACK){//on white
			//motor[leftMotor] = 32+(32*1.5-bkw)/6;
		  //motor[rightMotor] = bkw/1.5+(32/3-bkw)/6;
			//if(temp==0&&bkw>-32*1.5-(32*1.5-bkw)/6)
			//	bkw-=1;
			//else if(temp){
			//	bkw = 32*1.5;
			//	temp = 0;
			motor[leftMotor] = 20;
			motor[rightMotor]=-10;
			}
			//wait1Msec(10);
		}
	}


int unitTime(float lapTime){//converts angles into seconds
		int ans = (int)((float)RINVERSE*lapTime*1000/360.0);
		return ans;
}

float min_distance = 30; //min obstacle distance to trigger event (in)

bool readSonar(){
	nxtDisplayString(0, "Object Dist: %f", SensorValue[sonar]);
	if(SensorValue[sonar] <= min_distance){ //detected object 
		nxtDisplayString(1,"Object Detected");
		return true;
	}	
	else{
		return false;
	}	
}

void updateProbabilities(bool sonarReading, int distance){//updates the probability arrays
	distance = distance*RESOLUTION;//scales distance to match array length
	float temp[360*RESOLUTION]; //this array is the current probabilities shifted my the distance
	//these are for assigning values to temp**********************************
	for(int i = distance; i< 360*RESOLUTION; i++){
			temp[i] = currentProbs[i-distance];
	}
	for(int i = 0; i<distance;i++){
			temp[i] = currentProbs[360*RESOLUTION-distance+i];	
	}
	//****************************************************************
	//this one is for the actual algorithm
	for(int i = 0; i<360*RESOLUTION;i++){
		lastProbs[i] = sonarReading ? courseProbs[i] : 1.0-courseProbs[i];
		currentProbs[i] = lastProbs[i]*temp[i];
	}
	//finding the max of the prob array
	float max = -100.0;
	for(int i = 0;i<360*RESOLUTION;i++){
		if(currentProbs[i]>max){
			max = currentProbs[i];
			location = i*RINVERSE;
		}
	}
	
}

task localization(){
	//initializing courseProbs to the correct values***************************************
	int index = 0;
	for(int i = 0;i<16;i++){ //loop through course
		int prob = (course>>i)&1; //isolate last tick in course 
		//iterate through section representing obstacle and fill indices 
		for(int j = 0;j<22+i%2;j++){//22+j%2 is the closest you can get to 22.5 as an int
			index++;
			if(index<360*RESOLUTION){ //guarantee no segfault
				if(j<SPACE){ //conditional not being used, can't see space
					courseProbs[index] = prob;
				}
				else{
					courseProbs[index] = prob;
				}
			}
		}
	}
	//***********************************************************
	for(int i = 0;i<360*RESOLUTION;i++){
		currentProbs[i] = 1;	
	}
	int t = 0;
	while(true){
		wait1Msec(1);
		t++;
		//11.5 = time to travel around circle
		if(t>=unitTime(11.5)){ //every 5 miliseconds update probability
			nxtDisplayClearTextLine(0);
			nxtDisplayClearTextLine(1);
			nxtDisplayClearTextLine(2);
			updateProbabilities(readSonar(),5);
			nxtDisplayString(2,"%d",location);
			t=0;
		}
	}
}

task main()
{
	startTask(followLine);
	startTask(localization);
	while(true){}
	
	
}
