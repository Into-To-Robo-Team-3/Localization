#pragma config(Sensor, S1,     sonar,          sensorVexIQ_Distance)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RESOLUTION 1/5 //cells per degree
#define RINVERSE 5
#define WIDTH 17
#define SPACE 5.5
#define BLACK 40
#define POWER 50

float courseProbs[360*RESOLUTION];
float lastProbs[360*RESOLUTION];
float currentProbs[360*RESOLUTION];//probability arrays

short int course;
int location;

task followLine(){
	int temp = 0;
	int bkw = 35*1.5;
	/*start sequence
				int max_sweeps = 20; //# of times robot will sweep to find line
        int sweeps = 0; // iterator for sweeps
        int sweep_time = 1; // duration of sweep
        int dir = 2; // check right first
        while(true){
            sweep_time += 2*sweeps*sweeps;
            if(dir == 1){ //Turn left
                motor[leftMotor] = -30;
                motor[rightMotor] = 30;
            }
            else if(dir == 2){ //Turn right
                motor[leftMotor] = 30;
                motor[rightMotor] = -30;
            }
            int temp = 0;
            for(int t = 0;t<sweep_time;t++){ // time spent sweeping
	            if(SensorValue(light) < BLACK){ // found line
	                dir = 0; // go straight again
	                temp = 1;
	                break;
	            }
	            wait1Msec(1);
          	}
          	if(temp) break;
            if(sweeps > max_sweeps) break; // reached max n# of sweeps
            // switch direction of sweep
            if(dir == 1) dir = 2;
            else dir = 1;
            sweeps += 1;
      		}*/
	while(true){
		motor[leftMotor]=30;
		if(SensorValue(light)<BLACK){
			//motor[leftMotor] = 30;
			motor[rightMotor] = 19;
			temp = 1;
			//wait1Msec(10);
		}
		if(SensorValue(light)>BLACK){//on white
			//motor[leftMotor] = 32+(32*1.5-bkw)/6;
		  //motor[rightMotor] = bkw/1.5+(32/3-bkw)/6;
			//if(temp==0&&bkw>-32*1.5-(32*1.5-bkw)/6)
			//	bkw-=1;
			//else if(temp){
			//	bkw = 32*1.5;
			//	temp = 0;
			//motor[leftMotor] = 30;
			motor[rightMotor]=-4;
			}
			//wait1Msec(10);
		}
	}


int unitTime(float lapTime){//converts angles into seconds
		return (int)((float)RINVERSE*lapTime/360.0);
}

float min_distance = 10; //min obstacle distance to trigger event (in)

bool readSonar(){
	nxtDisplayString(0, "Object Dist: %f", SensorValue[sonar]);
	if(SensorValue[sonar] <= min_distance){ //detected object 
		nxtDisplayString(1,"Object Detected");
		return true;
	}	
	else{
		return false;
	}	
}

void updateProbabilities(bool sonarReading, int distance){//updates the probability arrays
	distance = distance*RESOLUTION;
	float temp[360*RESOLUTION];
	for(int i = distance; i< 360*RESOLUTION; i++){
			temp[i] = currentProbs[i-distance];
	}
	for(int i = 0; i<distance;i++){
			temp[i] = currentProbs[360-distance+i];	
	}
	for(int i = 0; i<360*RESOLUTION;i++){
		lastProbs[i] = sonarReading ? courseProbs[i]:1-courseProbs[i];
		currentProbs[i] = lastProbs[i]*temp[i];
	}
	int max = 0;
	for(int i = 0;i<360*RESOLUTION;i++){
		if(currentProbs[i]>max){
			max = currentProbs[i];
			location = i*RINVERSE;
		}
	}
	
}

task localization(){
	for(int i = 0;i<16;i++){
		int prob = (course>>i)&1;
		for(int j = 0;j<22+i%2;j++){//22+j%2 is the closest you can get to 22.5 as an int
				if(j<SPACE){
					courseProbs[i*360/16+j] = 0;
				}
				else{
					courseProbs[i*360/16+j] = prob;
				}
		}
	}
	while(true){
		int t = 0;
		wait1Msec(1);
		t++;
		if(t>=unitTime(11.5)){ //every 5 miliseconds update probability
			updateProbabilities(readSonar(),1);
			nxtDisplayString(2,"%d",location);
			t=0;
		}
	}
}

task main()
{
	startTask(followLine);
	startTask(localization);
	while(true){}
	
	
}
